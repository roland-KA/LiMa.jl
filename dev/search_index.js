var documenterSearchIndex = {"docs":
[{"location":"AppCore/AppCore/#AppCore","page":"AppCore Overview","title":"AppCore","text":"","category":"section"},{"location":"AppCore/AppCore/","page":"AppCore Overview","title":"AppCore Overview","text":"Business Logic –> A-Software","category":"page"},{"location":"AppCore/AppCore/","page":"AppCore Overview","title":"AppCore Overview","text":"  AppCore","category":"page"},{"location":"AppCore/AppCore/#LiMa.AppCore","page":"AppCore Overview","title":"LiMa.AppCore","text":"Business logic of the library manager\n\n\n\n\n\n","category":"module"},{"location":"StorageManager/#StorageManager","page":"StorageManager","title":"StorageManager","text":"","category":"section"},{"location":"StorageManager/#Overview","page":"StorageManager","title":"Overview","text":"","category":"section"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"The StorageManager is an object pool which stores its objects permanently. ","category":"page"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"A pool is basically a container for objects. It manages these objects over their lifetime  and offers some additional services for them, e.g. access control, sharing across systems or,  as in our case, persistence.","category":"page"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"A pool offers the following interface:","category":"page"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"insert!(pool,obj) -> id:  Insert an object (that has been created outside) into the pool and return its id\ncreate!(pool,type,attrs) -> obj:  Create (within the pool) a new object of type using the attributes attrs and return it\nupdate!(pool,type,id,attrs) –> obj: Update the object objof type with id with the new attribute attrsand return the updated object\nexists(pool,type,id) -> Bool:  Does an object obj of type with id exist within the pool?\nget(pool,type,id) -> obj:  Retrieve an object obj of type with id from the pool (exactly one)\ndelete!(pool,type,id):  Delete an exisiting object obj of type with id from the pool \nlookup(pool,query,args) -> Iterable<obj>:  Search for objects using a query with search terms;  the result is an iterable collection of objects (which may contain 0, 1 oder more elements)","category":"page"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"This interface definition differs from some more generic pool interfaces as it assumes that each object is of a specific type and has some unique id. We come to that point in more detail lateron.","category":"page"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"The StorageManager offers persistence with transaction control. Therefore it has also the  following transaction interface:","category":"page"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"begin_transaction(pool): Mark the begin of a transaction\ncommit(pool): End a transaction and make all changes permanent\nrollback(pool): End a transaction and rollback all changes\nset_autocommit(pool, Bool): Sets the autocommit-mode which is by default true. In this case each operation is considered being a single transaction which is commited immediately after execution. The above mentioned transaction commands are only meaningful, if this mode is set to false.","category":"page"},{"location":"StorageManager/#Data-managed-by-StorageManager","page":"StorageManager","title":"Data managed by StorageManager","text":"","category":"section"},{"location":"StorageManager/#Requirements","page":"StorageManager","title":"Requirements","text":"","category":"section"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"The data managed by the StorageManager has to fullfill certain requirements:","category":"page"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"it must be a used-defined mutable composite type (UDMCT)\nit must have an attribute id::Int64 which is managed by the StorageManager; this id is a unique identifier for all objects of a specific type\nits attributes may have one of the following data types\na Julia primitive type, a STRING or a  DATE (i.e. types which can be easily mapped to a corresponding SQL data type)\nanother UDMCT\nan iterable collection, containing objects of the same type (i.e. all objects returned by the Iterator for this collection have an identical eltype )","category":"page"},{"location":"StorageManager/#Examples","page":"StorageManager","title":"Examples","text":"","category":"section"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"The following definitions of UDMCTs from the LiMa-Application are typical examples of data which can be managed by StorageManager:","category":"page"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"mutable struct User \n    id::Int64            # managed by `StorageManager`\n    name::String\n    firstname::String\n    birthdate::Date\n    address::Address      # another UDMCT-type\nend\n\nmutable struct Address \n    id::Int64\n    street::String\n    housenumber::String\n    city::String\n    zip::String\n    country::String\nend","category":"page"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"Most of their attributes are „simple“ data types (category 1); only User declares one attribute (address) whose type is an UDMCT.","category":"page"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"The next definitions contain an example, where a collection-type is used:","category":"page"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"mutable struct Author\n    id::Int64\n    name1::String       # firstname\n    name2::String       # more names (if they exist)\n    name3::String       # familyname, organisation (if not a person)\n    affiliation::String\nend\n\nmutable struct Title \n    id::Int64\n    titleID::String     # unique identifier used by the library\n    isbn::String        # not all titles may hav a ISBN\n    name::String        # title\n    author::AbstractArray{Author}\n    publisher::String\n    pub_date::Date\nend","category":"page"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"A Title may have one or more authors. Therefore the attribute author is defined as an AbstractArray{Author}, which is an iterable collection.","category":"page"},{"location":"StorageManager/#Use-of-StructTypes","page":"StorageManager","title":"Use of StructTypes","text":"","category":"section"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"TODO","category":"page"},{"location":"StorageManager/#StorageManager-–-Public-Interface","page":"StorageManager","title":"StorageManager – Public Interface","text":"","category":"section"},{"location":"StorageManager/#Usage-of-the-storage-pool","page":"StorageManager","title":"Usage of the storage pool","text":"","category":"section"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"LiMa.StorageManager.insert!\nLiMa.StorageManager.create!\nLiMa.StorageManager.update!\nLiMa.StorageManager.exists\nLiMa.StorageManager.get\nLiMa.StorageManager.delete!\nLiMa.StorageManager.lookup","category":"page"},{"location":"StorageManager/#LiMa.StorageManager.insert!","page":"StorageManager","title":"LiMa.StorageManager.insert!","text":"insert!(pool::StoragePool, obj::Any)\n\nInsert an object (created outside) into the storage pool. \n\n\n\n\n\n","category":"function"},{"location":"StorageManager/#LiMa.StorageManager.create!","page":"StorageManager","title":"LiMa.StorageManager.create!","text":"create!(pool::StoragePool, type::DataType, attrs::Tuple) --> obj\n\nCreate an object of type type from attrs within the pool and return that new object.\n\n\n\n\n\n","category":"function"},{"location":"StorageManager/#LiMa.StorageManager.update!","page":"StorageManager","title":"LiMa.StorageManager.update!","text":"update!(pool::StoragePool, type::DataType, id::Int64, attrs::Tuple) --> obj\n\nUpdate the existing object of type type identified by id with the new attributes attrs and return the updated object.\n\n\n\n\n\n","category":"function"},{"location":"StorageManager/#LiMa.StorageManager.exists","page":"StorageManager","title":"LiMa.StorageManager.exists","text":"exists(pool::StoragePool, type::DataType, id::Int64) --> Bool\n\nIs there an object of type type identified by id within the pool?\n\n\n\n\n\n","category":"function"},{"location":"StorageManager/#LiMa.StorageManager.get","page":"StorageManager","title":"LiMa.StorageManager.get","text":"get(pool::StoragePool, type::DataType, id::Int64) --> obj\n\nRetrieve an object of type type identified by id.\n\n\n\n\n\n","category":"function"},{"location":"StorageManager/#LiMa.StorageManager.delete!","page":"StorageManager","title":"LiMa.StorageManager.delete!","text":"delete!(pool::StoragePool, type::DataType, id::Int64)\n\nDelete the object of type type identified by id from the pool.\n\n\n\n\n\n","category":"function"},{"location":"StorageManager/#LiMa.StorageManager.lookup","page":"StorageManager","title":"LiMa.StorageManager.lookup","text":"lookup(pool::StoragePool, query::String, args::Tuple) --> Iterable{obj}\n\nSearch for objects using a query with search terms;  the result is an iterable collection of objects (which may contain 0, 1 oder more elements)\n\n\n\n\n\n","category":"function"},{"location":"StorageManager/#Transaction-Management","page":"StorageManager","title":"Transaction Management","text":"","category":"section"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"begin_transaction\ncommit\nrollback\nset_autocommit","category":"page"},{"location":"StorageManager/#LiMa.StorageManager.begin_transaction","page":"StorageManager","title":"LiMa.StorageManager.begin_transaction","text":"begin_transaction(pool::StoragePool)\n\nMark the begin of a transaction.\n\n\n\n\n\n","category":"function"},{"location":"StorageManager/#LiMa.StorageManager.commit","page":"StorageManager","title":"LiMa.StorageManager.commit","text":"commit(pool::StoragePool)\n\nEnd a transaction and make all changes permanent.\n\n\n\n\n\n","category":"function"},{"location":"StorageManager/#LiMa.StorageManager.rollback","page":"StorageManager","title":"LiMa.StorageManager.rollback","text":"rollback(pool::StoragePool)\n\nEnd a transaction and rollback all changes.\n\n\n\n\n\n","category":"function"},{"location":"StorageManager/#LiMa.StorageManager.set_autocommit","page":"StorageManager","title":"LiMa.StorageManager.set_autocommit","text":"set_autocommit(pool::StoragePool, mode::Bool)\n\nSets the autocommit-mode which is by default true. In this case each operation is considered  being a single transaction which is commited immediately after execution. The above mentioned  transaction commands are only meaningful, if this mode is set to false.\n\n\n\n\n\n","category":"function"},{"location":"StorageManager/#Persistence-Layer","page":"StorageManager","title":"Persistence Layer","text":"","category":"section"},{"location":"StorageManager/#Object-Creation","page":"StorageManager","title":"Object Creation","text":"","category":"section"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"In Julia a generic creation mechanism is possible using meta programming. E.g. the following statement","category":"page"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"e = Expr(:call, Address, 1, \"a1\", \"a2\", \"a3\", \"a4\", \"a5\")","category":"page"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"creates a valid Julia expression (in this case a constructor for a new Address), which can be evaluated using eval, thus creating an Address- object.","category":"page"},{"location":"StorageManager/","page":"StorageManager","title":"StorageManager","text":"This can be used to implement the create-function.","category":"page"},{"location":"AppCore/UserManager/#UserManager","page":"UserManager","title":"UserManager","text":"","category":"section"},{"location":"AppCore/UserManager/","page":"UserManager","title":"UserManager","text":"The first part of the application core to be implemented is the UserManager.","category":"page"},{"location":"AppCore/UserManager/","page":"UserManager","title":"UserManager","text":"Modules = [AppCore.UserManager]\nOrder = [:type, :function]","category":"page"},{"location":"AppCore/UserManager/#LiMa.AppCore.UserManager.create_user-Tuple{String, String, Dates.Date, Address}","page":"UserManager","title":"LiMa.AppCore.UserManager.create_user","text":"create_user(name::String, firstname::String, birthdate::Date, address::Address)::User\n\nCreate a new user with the information given. Return the new user.\n\n\n\n\n\n","category":"method"},{"location":"AppCore/UserManager/#LiMa.AppCore.UserManager.delete_user-Tuple{Integer}","page":"UserManager","title":"LiMa.AppCore.UserManager.delete_user","text":"delete_user(userID::Integer)::Bool\n\nDelete the user userID from the system. Return true if such a user existed and could be deleted.\n\n\n\n\n\n","category":"method"},{"location":"AppCore/UserManager/#LiMa.AppCore.UserManager.get_user-Tuple{Integer}","page":"UserManager","title":"LiMa.AppCore.UserManager.get_user","text":"get_user(userID::Integer)::User\n\nReturn the user with ID userID. The user must exist (if not, a UserNotExists exepction occurs).\n\n\n\n\n\n","category":"method"},{"location":"AppCore/UserManager/#LiMa.AppCore.UserManager.search_users","page":"UserManager","title":"LiMa.AppCore.UserManager.search_users","text":"search_users(firstname = nothing, birthdate = nothing, address = nothing)::AbstractVector{User}\n\nSearch for users matching the attributes given. If no matching users are found, an empty list is returned.\n\n\n\n\n\n","category":"function"},{"location":"AppCore/UserManager/#LiMa.AppCore.UserManager.update_user-Tuple{Integer}","page":"UserManager","title":"LiMa.AppCore.UserManager.update_user","text":"update_user(userID::Integer; firstname = nothing, birthdate = nothing, address = nothing)::User\n\nUpdate the user information for user userID. Return the updated user. The information passed via the optional parameters will be updated.\n\n\n\n\n\n","category":"method"},{"location":"AppCore/UserManager/#LiMa.AppCore.UserManager.user_exists-Tuple{Integer}","page":"UserManager","title":"LiMa.AppCore.UserManager.user_exists","text":"user_exists(userID::Integer)::Bool\n\nCheck, if a user with userID exists.\n\n\n\n\n\n","category":"method"},{"location":"#LiMa-A-Library-Manager","page":"Introduction","title":"LiMa - A Library Manager","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is an information system for managing the typical processes of a library. It hast been built for educational purposes, in order to show and explain the principles of a software architecture which conforms to the concepts presented in: ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Johannes Siedersleben: Moderne Software-Architektur, dpunkt.verlag, 2004. ","category":"page"},{"location":"#Software-Categories","page":"Introduction","title":"Software Categories","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The main idea of this book is, that the components of a software architecture can be categorized into the following classes:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"0-Software: This is software that is neither application specific nor does it know some technical APIs. Examples are container data types, basic algorithms for sorting and searching, math libraries etc.\nA-Software: Application software that implements the business logic and is independent of any technical APIs.\nT-Software: Technical software that knows at least one technical API (like ODBC, JSON)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A good and maintainable architecture should avoid AT-Software (i.e. a mixture of A- and T-software). In order to connect A-components and T-componentes, so-called R-Software should be used. That is software which translates from one Representation to another (i.e. from the business domain to  the technical world and vice versa).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"R-Software has in many cases a simple structure, so that it may be generated automatically based on some configuration data.","category":"page"},{"location":"#Current-State","page":"Introduction","title":"Current State","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The software in this repo is a work in progress. It focuses currently on the subsystems","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"AppCore: the business logic (→ A-Software)\nStorageManager: a component responsible for storing and retrieving data; the StorageManager itself is a technology-neutral object manager [→ 0-Software].\nIt is using a relational DBMS (SQLite in this case) for storing the objects; from the Julia-side SQLite.jl and DBInterface.jlare used for access  [→ T-Software]\nIn between there is a layer of R-Software (StorageAdapter) to connect both worlds \nNote: In a more realistic scenario, the StorageManagerwouldn‘t be a sub-package of LiMa, but a stand-alone package which would be used by AppCore.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Comp-AppCore-StorageManager)","category":"page"},{"location":"#Business-Logic-in-AppCore","page":"Introduction","title":"Business Logic in AppCore","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The application core consists of the following components:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"UserManager\nTitleCatalog\nInventoryManager\nCirculationManager\nFees","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"  AppCore.UserManager","category":"page"},{"location":"#LiMa.AppCore.UserManager","page":"Introduction","title":"LiMa.AppCore.UserManager","text":"Management of library users\n\nFunctions for \n\ncreating new users\nupdating information for exisiting users\nactivating/deactivating existing users\ndeleting users \nsearching for existing users\n\nAs each user is associated with an address, the module is also responsible for their management.\n\n\n\n\n\n","category":"module"},{"location":"","page":"Introduction","title":"Introduction","text":"  AppCore.TitleCatalog","category":"page"},{"location":"#LiMa.AppCore.TitleCatalog","page":"Introduction","title":"LiMa.AppCore.TitleCatalog","text":"Management of titles and books\n\nThe catalog contains all titles the library offers as well as the corresponding copies. The titles and the associated (physical or electronic) copies have a lifecycle that has to be managed. As a title may have several authors, it is also the responsibility of  this module to manage the authors.\n\n\n\n\n\n","category":"module"}]
}
